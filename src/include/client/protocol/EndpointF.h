// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __ENDPOINTF_H_
#define __ENDPOINTF_H_

#include <map>
#include <string>
#include <vector>
#include "client/protocol/Tars.h"
using namespace std;


namespace horsedb
{
    struct EndpointF : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.EndpointF";
        }
        static string MD5()
        {
            return "150be7f7cdd22b6d644d53a697d24103";
        }
        EndpointF()
        :host(""),port(0),timeout(0),istcp(0),grid(0),groupworkid(0),grouprealid(0),setId(""),qos(0),bakFlag(0),weight(0),weightType(0),authType(0)
        {
        }
        void resetDefautlt()
        {
            host = "";
            port = 0;
            timeout = 0;
            istcp = 0;
            grid = 0;
            groupworkid = 0;
            grouprealid = 0;
            setId = "";
            qos = 0;
            bakFlag = 0;
            weight = 0;
            weightType = 0;
            authType = 0;
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(host, 0);
            _os.write(port, 1);
            _os.write(timeout, 2);
            _os.write(istcp, 3);
            _os.write(grid, 4);
            if (groupworkid != 0)
            {
                _os.write(groupworkid, 5);
            }
            if (grouprealid != 0)
            {
                _os.write(grouprealid, 6);
            }
            if (setId != "")
            {
                _os.write(setId, 7);
            }
            if (qos != 0)
            {
                _os.write(qos, 8);
            }
            if (bakFlag != 0)
            {
                _os.write(bakFlag, 9);
            }
            if (weight != 0)
            {
                _os.write(weight, 11);
            }
            if (weightType != 0)
            {
                _os.write(weightType, 12);
            }
            if (authType != 0)
            {
                _os.write(authType, 13);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(host, 0, true);
            _is.read(port, 1, true);
            _is.read(timeout, 2, true);
            _is.read(istcp, 3, true);
            _is.read(grid, 4, true);
            _is.read(groupworkid, 5, false);
            _is.read(grouprealid, 6, false);
            _is.read(setId, 7, false);
            _is.read(qos, 8, false);
            _is.read(bakFlag, 9, false);
            _is.read(weight, 11, false);
            _is.read(weightType, 12, false);
            _is.read(authType, 13, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(host,"host");
            _ds.display(port,"port");
            _ds.display(timeout,"timeout");
            _ds.display(istcp,"istcp");
            _ds.display(grid,"grid");
            _ds.display(groupworkid,"groupworkid");
            _ds.display(grouprealid,"grouprealid");
            _ds.display(setId,"setId");
            _ds.display(qos,"qos");
            _ds.display(bakFlag,"bakFlag");
            _ds.display(weight,"weight");
            _ds.display(weightType,"weightType");
            _ds.display(authType,"authType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(host, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(timeout, true);
            _ds.displaySimple(istcp, true);
            _ds.displaySimple(grid, true);
            _ds.displaySimple(groupworkid, true);
            _ds.displaySimple(grouprealid, true);
            _ds.displaySimple(setId, true);
            _ds.displaySimple(qos, true);
            _ds.displaySimple(bakFlag, true);
            _ds.displaySimple(weight, true);
            _ds.displaySimple(weightType, true);
            _ds.displaySimple(authType, false);
            return _os;
        }
    public:
        std::string host;
        horsedb::Int32 port;
        horsedb::Int32 timeout;
        horsedb::Int32 istcp;
        horsedb::Int32 grid;
        horsedb::Int32 groupworkid;
        horsedb::Int32 grouprealid;
        std::string setId;
        horsedb::Int32 qos;
        horsedb::Int32 bakFlag;
        horsedb::Int32 weight;
        horsedb::Int32 weightType;
        horsedb::Int32 authType;
    };
    inline bool operator==(const EndpointF&l, const EndpointF&r)
    {
        return l.host == r.host && l.port == r.port && l.timeout == r.timeout && l.istcp == r.istcp && l.grid == r.grid && l.groupworkid == r.groupworkid && l.grouprealid == r.grouprealid && l.setId == r.setId && l.qos == r.qos && l.bakFlag == r.bakFlag && l.weight == r.weight && l.weightType == r.weightType && l.authType == r.authType;
    }
    inline bool operator!=(const EndpointF&l, const EndpointF&r)
    {
        return !(l == r);
    }
    inline bool operator<(const EndpointF&l, const EndpointF&r)
    {
        if(l.host != r.host)  return (l.host < r.host);
        if(l.port != r.port)  return (l.port < r.port);
        if(l.timeout != r.timeout)  return (l.timeout < r.timeout);
        if(l.istcp != r.istcp)  return (l.istcp < r.istcp);
        if(l.grid != r.grid)  return (l.grid < r.grid);
        if(l.qos != r.qos)  return (l.qos < r.qos);
        if(l.weight != r.weight)  return (l.weight < r.weight);
        if(l.weightType != r.weightType)  return (l.weightType < r.weightType);
        if(l.authType != r.authType)  return (l.authType < r.authType);
        return false;
    }
    inline bool operator<=(const EndpointF&l, const EndpointF&r)
    {
        return !(r < l);
    }
    inline bool operator>(const EndpointF&l, const EndpointF&r)
    {
        return r < l;
    }
    inline bool operator>=(const EndpointF&l, const EndpointF&r)
    {
        return !(l < r);
    }


}



#endif
